gli oggetti stanno nello heap
le dispatch tables degli oggetti stanno nello heap
lo heap alloca da 0 -> n
no garbage collector




layout oggetti
hp   -> dopo allocazione di oggetto, heap pointer punta al niente
hp+1 -> 1-esimo campo
hp+2 -> 2-esimo campo
.
.
hp+n -> n-esimo campo
hp+n+1 -> dispatch pointer (tutti i puntatori a questo oggetto puntano qui)

l'i-esimo campo dell'oggetto si trova a (dp-i-1)
(dp sta per dispatch pointer)



layout dispatch tables (tabella dei metodi)
[...............................] <- hp   (dopo allocazione tabella)

l'i-esimo metodo dell'oggetto si trova a (dp+i-1)
(dp sta per dispatch pointer)





--- classi ---
dichiarazioni solo in ambiente globale e all'inizio
A.B() invoca il metodo B appartenente all'oggetto A
new A() istanzia un nuovo oggetto di classe A
null è un valore di tipo object
il tipo di una classe è un ID
i campi di una classe sono descritti come parametri di una funzione

non serve nesting level per classi/oggetti perchè non è permesso dichiarare classi dentro altre classi

la class table tiene, per ogni classe, un riferimento ad una virtual table
la virtual table di una classe contiene la lista di tutte le dichiarazione dei suoi campi e dei suoi metodi
servono per forza due table diverse perchè i metodi di una classe non si cancellano mai, si allocano solamente una volta
invece i campi si allocano per ogni oggetto






--- oggetti ---
gli oggetti sono immutabili
i campi di un oggetto sono private final, da fuori non sono visibili e da dentro un metodo dell'oggetto si possono solo leggere
il campo x di un oggetto si può leggere come "x+5" da dentro l'oggetto
il metodo m dell'oggetto x si può invocare dall'interno come "m()" o dall'esterno come "x.m()"










--- ereditarietà ---
"class A extends B" dichiara una classe di tipo A figlia della classe B (esistente)

il costruttore della classe figlia ha all'inizio i parametri impliciti della classe padre, cioè
class A (a:int, b:bool) {...}
class B extends A (c:int) {...}
l'oggetto B si costruisce così B(5, true, 7)

se nel costruttore della classe figlia compaiono parametri con lo stesso ID di altri della classe padre, si fa overriding (i parametri non sono posizionali)
class A (a:int, b:bool) {...}
class B extends A (c:int, a:bool) {...}
l'oggetto A ha il campo a int, ma l'oggetto B ha il campo a bool







--- code optimization ---






--- node types ---
ClassNode        dichiarazione di una classe "class A {...}"
FieldNode        dichiarazione di un campo di una classe
MethodNode       dichiarazione di un metodo  (l'invocazione dall'interno è un CallNode)
ClassCallNode    chiamata a metodo dall'esterno "A.B()"
NewNode          istanziazione di un oggetto con "new"  (torna un RefTypeNode)
EmptyNode        "null"

ClassTypeNode    tipo di una classe
MethodTypeNode   tipo in STentry per i metodi (per distinguerli dalla funzioni)
RefTypeNode      riferimento ad una classe(?)
EmptyTypeNode    tipo di "null" (restituito dal typecheck di EmptyNode)



FieldNode è un ParNode
MethodNode è un FunNode
(perchè così ereditano da DecNode che ha il type)

Il tipo nella STentry dei metodi è MethodTypeNode
MethodTypeNode ha un "final ArrowTypeNode fun"


--- OFFSET ---
-1 fields
0 methods

lo stack cresce da 0 verso l'alto
l'heap cresce da MEMSIZE-1 verso il basso